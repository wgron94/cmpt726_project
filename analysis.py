"""
This module contains functions for post-processing of the registered scenes.
This includes: plotting warps, comparing with Gamma speckle tracking maps, etc
"""
import os.path
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.axes_grid1 import AxesGrid
import matplotlib.pyplot as plt
import numpy as np
import scipy.ndimage
import torch
import sarlab.gammax as gx
from .generators import scale_rmli


def plot_warp(warp_fname, show=False):
    """
    Plots the offsets in the warp file generated by voxelmorph.
    Saves the plots to the directory containing the warp.
    """
    warp_file = np.load(warp_fname)
    outdir = os.path.dirname(warp_fname)
    warp_basename = os.path.splitext(os.path.basename(warp_fname))[0]
    plt_fname = os.path.join(outdir, warp_basename + '.png')
    offsets = warp_file['offs']
    rg_offs = offsets[0, :, :].T
    az_offs = offsets[1, :, :].T

    min_rg_off = np.amin(rg_offs) * 0.9
    max_rg_off = np.amax(rg_offs) * 0.9
    min_az_off = np.amin(az_offs) * 0.9
    max_az_off = np.amax(az_offs) * 0.9
    fig, (rg_ax, az_ax) = plt.subplots(1, 2, figsize=(8, 4), sharey=True)

    im_rg = rg_ax.imshow(rg_offs, vmin=min_rg_off, vmax=max_rg_off)
    rg_ax.set_title('Range offsets (pixels)')
    rg_ax.set_xlabel('Range')
    rg_ax.set_ylabel('Azimuth')
    fig.colorbar(im_rg, ax=rg_ax)

    im_az = az_ax.imshow(az_offs, vmin=min_az_off, vmax=max_az_off)
    az_ax.set_title('Azimuth offsets (pixels)')
    az_ax.set_xlabel('Range')
    az_ax.set_ylabel('Azimuth')
    fig.colorbar(im_az, ax=az_ax)
    fig.savefig(plt_fname)

    plt.figure()
    plt.imshow(offsets[0, :, :].T)
    plt.title('Range offsets')
    plt.colorbar()
    plt.savefig(os.path.join(outdir, 'range_offs.png'))

    plt.figure()
    plt.imshow(offsets[1, :, :].T)
    plt.title('Azimuth offsets')
    plt.colorbar()
    plt.savefig(os.path.join(outdir, 'azimuth_offs.png'))

    if show:
        plt.show()


def plot_warped_image(moving_rmli_fname, moved_npz_fname, crop_center,
                      crop_size, show=False):
    """
    Plots the moving image, moved image, and offsets for debugging and general
    visualization.

    Args:
        moving_rmli_fname (str): Filename of the RMLI moving scene
                                 (Gamma format)
        moved_npz_fname (str): Filename of the registered image
        crop_center (Tuple[int, int]): Rg, az center of the cropped chip
        crop_size (Tuple[int, int]): Rg, az size of the cropped chip
    """
    # Read moved scene
    moved_file = np.load(moved_npz_fname)
    moved = moved_file['scene'].T

    # Read moving scene
    rmli_scene = gx.MLI(moving_rmli_fname,
                        par=gx.MLI_Par(moving_rmli_fname + '.par')).array
    if (crop_center[0] < crop_size[0] // 2)\
            or (crop_center[1] < crop_size[1] // 2)\
            or (rmli_scene.shape[0] - crop_center[0] < crop_size[0] // 2)\
            or (rmli_scene.shape[1] - crop_center[1] < crop_size[1] // 2):
        raise ValueError('Center coordinates are too close to the edge')
    moving = rmli_scene[crop_center[0] - crop_size[0] // 2:crop_center[0] + crop_size[0] // 2,
                        crop_center[1] - crop_size[1] // 2:crop_center[1] + crop_size[1] // 2]
    moving = scale_rmli(moving).T

    # Plot filename
    moved_basename = os.path.splitext(os.path.basename(moved_npz_fname))[0]
    plt_fname = os.path.join(os.path.dirname(moved_npz_fname),
                             moved_basename + '.png')

    # Create the plot
    fig, (moving_ax, moved_ax) = plt.subplots(1, 2, figsize=(8, 4),
                                              sharey=True)
    moving_ax.imshow(moving)
    moving_ax.set_title('Moving image')
    moving_ax.set_xlabel('Range')
    moving_ax.set_ylabel('Azimuth')
    im = moved_ax.imshow(moved)
    moved_ax.set_title('Moved image')
    moved_ax.set_xlabel('Range')
    moved_ax.set_ylabel('Azimuth')
    fig.subplots_adjust(right=0.8)
    cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
    fig.colorbar(im, cax=cbar_ax)
    fig.savefig(plt_fname)

    if show:
        plt.show()


def loss_comparison(warp_fname, offpar_fname, moving_rmli_fname,
                    fixed_rmli_fname, moved_fname, crop_center, crop_size,
                    reg_weight, ncc_win, debug=False):
    """
    Computes the similarity loss and smoothness loss for both the Voxelmorph
    offsets and equivalent Gamma offsets for comparison.

    Args:
        warp_fname (str): Filename of the voxelmorph warp output
        offpar_fname (str): Filename of the Gamma offpar (assumes the Gamma
            speckle tracking offsets have the same base name)
        moving_rmli_fname (str): Filename of the moving scene RMLI data
        fixed_rmli_fname (str): Filename of the fixed scene RMLI data
        moved_fname (str): Filename of the moved scene (.npz format)
        crop_center (Tuple[int, int]): Rg, az center of cropped chip
        crop_size (Tuple[int, int]): Rg, az size of cropped chip
        reg_weight (float): Lambda, regularization weight.
            Total loss = similarity + lambda * smoothness
        ncc_win (int): NCC window size
        show (bool): Call plt.show() if true

    """
    rg_crop = crop_size[0]
    az_crop = crop_size[1]
    rg_cen = crop_center[0]
    az_cen = crop_center[1]

    # Import voxelmorph with pytorch backend
    os.environ['VXM_BACKEND'] = 'pytorch'
    import voxelmorph as vxm

    # Read the voxelmorph warp file
    warp_file = np.load(warp_fname)
    warp = warp_file['offs']
    warp = warp[np.newaxis, :, :, :]

    # Read moved scene
    moved_file = np.load(moved_fname)
    moved = moved_file['scene']
    moved = moved[np.newaxis, np.newaxis, :, :]

    # Read, crop, and scale the fixed RMLI
    fixed_rmli = gx.MLI(fixed_rmli_fname,
                        par=gx.MLI_Par(fixed_rmli_fname + '.par'))
    rmli_dim = fixed_rmli.dim
    fixed_full = fixed_rmli.array
    fixed = fixed_full[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                       az_cen - az_crop // 2:az_cen + az_crop // 2]
    fixed = scale_rmli(fixed)
    fixed = fixed[np.newaxis, np.newaxis, :, :]

    # Read, crop, and scale the moving RMLI
    moving_rmli = gx.MLI(moving_rmli_fname,
                        par=gx.MLI_Par(moving_rmli_fname + '.par'))
    moving_full = moving_rmli.array
    moving = moving_full[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                         az_cen - az_crop // 2:az_cen + az_crop // 2]
    moving = scale_rmli(moving)
    moving = moving[np.newaxis, np.newaxis, :, :]

    # Read in the Gamma offsets
    # Scale the Gamma offsets to be the same size as the original data that
    # was cropped to feed into voxelmorph.
    offs_basename, _ = os.path.splitext(os.path.basename(offpar_fname))
    offs_fname = os.path.join(os.path.dirname(offpar_fname), offs_basename + '.offs')
    offpar = gx.OFF_Par(offpar_fname)
    offs_dim = (offpar['offset_estimation_range_samples'],
                offpar['offset_estimation_azimuth_samples'])
    gx_offs = gx.readBin(offs_fname, offs_dim, _dtype='complex64')
    zoom_factor = (rmli_dim[0] / offs_dim[0], rmli_dim[1] / offs_dim[1])
    multilook = (fixed_rmli.par['range_looks'],
                 fixed_rmli.par['azimuth_looks'])
    gamma_rg_offs = scipy.ndimage.zoom(np.real(gx_offs), zoom_factor)
    gamma_az_offs = scipy.ndimage.zoom(np.imag(gx_offs), zoom_factor)
    gamma_rg_offs = gamma_rg_offs[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                                  az_cen - az_crop // 2:az_cen + az_crop // 2]
    gamma_rg_offs /= multilook[0]
    gamma_az_offs = gamma_az_offs[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                                  az_cen - az_crop // 2:az_cen + az_crop // 2]
    gamma_az_offs /= multilook[1]
    gamma_warp = np.stack((gamma_rg_offs, gamma_az_offs), axis=0)
    gamma_warp = gamma_warp[np.newaxis, :, :, :]

    # Create a moved image with the gamma offsets
    transformer = vxm.layers.SpatialTransformer(crop_size)
    gamma_moved = transformer(torch.from_numpy(moving).float(),
                              torch.from_numpy(gamma_warp).float())

    # Prepare ncc loss with square window
    ndims = len(list(fixed.shape)) - 2
    assert ndims in [1, 2, 3], "volumes should be 1 to 3 dimensions. found: %d" % ndims
    ncc_win_sq = [ncc_win] * ndims  # Build a square window
    ncc = vxm.losses.NCC(ncc_win_sq, cuda=False)

    # Now we have all the data, compute the losses
    loss_sim_vxm = ncc.loss(torch.from_numpy(fixed).float(),
                            torch.from_numpy(moved).float())
    loss_sim_gamma = ncc.loss(torch.from_numpy(fixed).float(), gamma_moved)

    grad = vxm.losses.Grad(penalty='l2')
    loss_smooth_vxm = grad.loss(None, torch.from_numpy(warp).float())
    loss_smooth_gamma = grad.loss(None, torch.from_numpy(gamma_warp).float())

    loss_total_vxm = loss_sim_vxm + (reg_weight * loss_smooth_vxm)
    loss_total_gamma = loss_sim_gamma + (reg_weight * loss_smooth_gamma)

    # Print everything
    print('Lambda: {}\n'.format(reg_weight))
    print('Voxelmorph:\nSimilarity loss: {}\nSmoothness loss: {}\n'
          'Total: {}\n'.format(loss_sim_vxm, loss_smooth_vxm, loss_total_vxm))
    print('Gamma:\nSimilarity loss: {}\nSmoothness loss: {}\n'
          'Total: {}\n'.format(loss_sim_gamma, loss_smooth_gamma, loss_total_gamma))

    if debug:
        plt.figure()
        plt.imshow(moved[0, 0, :, :])
        plt.title('moved')
        plt.colorbar()
        plt.figure()
        plt.imshow(gamma_moved[0, 0, :, :])
        plt.title('gamma_moved')
        plt.colorbar()
        plt.figure()
        plt.imshow(fixed[0, 0, :, :])
        plt.title('fixed')
        plt.colorbar()
        plt.figure()
        plt.imshow(warp[0, 0, :, :])
        plt.title('warp_rg')
        plt.colorbar()
        plt.figure()
        plt.imshow(warp[0, 1, :, :])
        plt.title('warp_az')
        plt.colorbar()
        plt.figure()
        plt.imshow(gamma_warp[0, 0, :, :])
        plt.title('gamma_warp_rg')
        plt.colorbar()
        plt.figure()
        plt.imshow(gamma_warp[0, 1, :, :])
        plt.title('gamma_warp_az')
        plt.colorbar()
        plt.show()


def plot_gamma_comparison(warp_fname, offpar_fname, crop_center, crop_size,
                          full_scene_dim, multilook, show=False):
    """
    Plots the offsets compared to Gamma offsets.

    Resizes the Gamma offsets to be directly comparable.

    Args:
        warp_fname (str): Filename of the voxelmorph warp output
        offpar_fname (str): Filename of the Gamma offpar
        crop_center (Tuple[int, int]): Rg, az center of cropped chip
        crop_size (Tuple[int, int]): Rg, az size of cropped chip
        full_scene_dim (Tuple[int, int]): Rg, az size of the full RMLI scene
        multilook (Tuple[int, int]): Rg, az multilook factor
        show (bool): Call plt.show() if true
    """
    warp_file = np.load(warp_fname)
    vxm_rg_offs = warp_file['offs'][0, :, :]
    vxm_az_offs = warp_file['offs'][1, :, :]

    # Read in the Gamma format offsets
    offs_basename, _ = os.path.splitext(os.path.basename(offpar_fname))
    offs_fname = os.path.join(os.path.dirname(offpar_fname), offs_basename + '.offs')
    offpar = gx.OFF_Par(offpar_fname)
    offs_dim = (offpar['offset_estimation_range_samples'],
               offpar['offset_estimation_azimuth_samples'])
    gx_offs = gx.readBin(offs_fname, offs_dim, _dtype='complex64')

    # Scale the Gamma offsets to be the same size as the original data that
    # was cropped to feed into voxelmorph.
    zoom_factor = (full_scene_dim[0] / offs_dim[0],
                   full_scene_dim[1] / offs_dim[1])
    gamma_rg_offs = scipy.ndimage.zoom(np.real(gx_offs), zoom_factor)
    gamma_az_offs = scipy.ndimage.zoom(np.imag(gx_offs), zoom_factor)

    # Now grab the same cropped area out from the Gamma offsets as what was
    # used to input into the Voxelmorph network
    rg_crop = crop_size[0]
    az_crop = crop_size[1]
    rg_cen = crop_center[0]
    az_cen = crop_center[1]
    gamma_rg_offs = gamma_rg_offs[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                                  az_cen - az_crop // 2:az_cen + az_crop // 2]
    gamma_rg_offs /= multilook[0]
    gamma_az_offs = gamma_az_offs[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                                  az_cen - az_crop // 2:az_cen + az_crop // 2]
    gamma_az_offs /= multilook[1]

    # Range plots
    min_rg_off = np.amin(gamma_rg_offs) * 0.9
    max_rg_off = np.amax(gamma_rg_offs) * 0.9
    fig_rg, (vxm_rg_ax, gx_rg_ax) = plt.subplots(1, 2, figsize=(8, 4),
                                                 sharey=True)
    rg_plot_fname = os.path.join(os.path.dirname(warp_fname),
                                 offs_basename + '_rg_offs.png')
    vxm_rg_ax.imshow(vxm_rg_offs.T, vmin=min_rg_off, vmax=max_rg_off)
    vxm_rg_ax.set_title('Voxelmorph range offsets (pixels)')
    vxm_rg_ax.set_xlabel('Range')
    vxm_rg_ax.set_ylabel('Azimuth')
    im = gx_rg_ax.imshow(gamma_rg_offs.T, vmin=min_rg_off, vmax=max_rg_off)
    gx_rg_ax.set_title('Gamma range offsets (pixels)')
    gx_rg_ax.set_xlabel('Range')
    gx_rg_ax.set_ylabel('Azimuth')
    fig_rg.subplots_adjust(right=0.8)
    cbar_ax = fig_rg.add_axes([0.85, 0.15, 0.05, 0.7])
    fig_rg.colorbar(im, cax=cbar_ax)
    fig_rg.savefig(rg_plot_fname)

    # Azimuth plots
    min_az_off = np.amin(gamma_az_offs) * 0.9
    max_az_off = np.amax(gamma_az_offs) * 0.9
    fig_az, (vxm_az_ax, gx_az_ax) = plt.subplots(1, 2, figsize=(8, 4),
                                                 sharey=True)
    az_plot_fname = os.path.join(os.path.dirname(warp_fname),
                                 offs_basename + '_az_offs.png')
    vxm_az_ax.imshow(vxm_az_offs.T, vmin=min_az_off, vmax=max_az_off)
    vxm_az_ax.set_title('Voxelmorph azimuth offsets (pixels)')
    vxm_az_ax.set_xlabel('Range')
    vxm_az_ax.set_ylabel('Azimuth')
    im = gx_az_ax.imshow(gamma_az_offs.T, vmin=min_az_off, vmax=max_az_off)
    gx_az_ax.set_title('Gamma azimuth offsets (pixels)')
    gx_az_ax.set_xlabel('Range')
    gx_az_ax.set_ylabel('Azimuth')
    fig_az.subplots_adjust(right=0.8)
    cbar_ax = fig_az.add_axes([0.85, 0.15, 0.05, 0.7])
    fig_az.colorbar(im, cax=cbar_ax)
    fig_az.savefig(az_plot_fname)

    if show:
        plt.show()

def loss_vxm(warp_fname, moving_rmli_fname,
                    fixed_rmli_fname, moved_fname, crop_center, crop_size,
                    reg_weight, ncc_win):
    """
    Computes the similarity loss and smoothness loss for Voxelmorph offset

    Args:
        warp_fname (str): Filename of the voxelmorph warp output
        moving_rmli_fname (str): Filename of the moving scene RMLI data
        fixed_rmli_fname (str): Filename of the fixed scene RMLI data
        moved_fname (str): Filename of the moved scene (.npz format)
        crop_center (Tuple[int, int]): Rg, az center of cropped chip
        crop_size (Tuple[int, int]): Rg, az size of cropped chip
        reg_weight (float): Lambda, regularization weight.
            Total loss = similarity + lambda * smoothness
        ncc_win (int): NCC window size

    """

    # Import voxelmorph with pytorch backend
    os.environ['VXM_BACKEND'] = 'pytorch'
    import voxelmorph as vxm

    rg_crop = crop_size[0]
    az_crop = crop_size[1]
    rg_cen = crop_center[0]
    az_cen = crop_center[1]

    # Read the voxelmorph warp file
    warp_file = np.load(warp_fname)
    warp = warp_file['offs']
    warp = warp[np.newaxis, :, :, :]

    # Read moved scene
    moved_file = np.load(moved_fname)
    moved = moved_file['scene']
    moved = moved[np.newaxis, np.newaxis, :, :]

    # Read, crop, and scale the fixed RMLI
    fixed_rmli = gx.MLI(fixed_rmli_fname,
                        par=gx.MLI_Par(fixed_rmli_fname + '.par'))
    rmli_dim = fixed_rmli.dim
    fixed_full = fixed_rmli.array
    fixed = fixed_full[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                       az_cen - az_crop // 2:az_cen + az_crop // 2]
    fixed = scale_rmli(fixed)
    fixed = fixed[np.newaxis, np.newaxis, :, :]

    # Read, crop, and scale the moving RMLI
    moving_rmli = gx.MLI(moving_rmli_fname,
                        par=gx.MLI_Par(moving_rmli_fname + '.par'))
    moving_full = moving_rmli.array
    moving = moving_full[rg_cen - rg_crop // 2:rg_cen + rg_crop // 2,
                         az_cen - az_crop // 2:az_cen + az_crop // 2]
    moving = scale_rmli(moving)
    moving = moving[np.newaxis, np.newaxis, :, :]

    # Prepare ncc loss with square window
    ndims = len(list(fixed.shape)) - 2
    assert ndims in [1, 2, 3], "volumes should be 1 to 3 dimensions. found: %d" % ndims
    ncc_win_sq = [ncc_win] * ndims  # Build a square window
    ncc = vxm.losses.NCC(ncc_win_sq, cuda=False)

    # Now we have all the data, compute the losses
    loss_sim_vxm = ncc.loss(torch.from_numpy(fixed).float(), torch.from_numpy(moved).float())

    grad = vxm.losses.Grad(penalty='l2')
    loss_smooth_vxm = grad.loss(None, torch.from_numpy(warp).float())

    loss_total_vxm = loss_sim_vxm + (reg_weight * loss_smooth_vxm)

    # Print everything
    # print('Lambda: {}\n'.format(reg_weight))
    # print('Voxelmorph:\nSimilarity loss: {}\nSmoothness loss: {}\n'
          #'Total: {}\n'.format(loss_sim_vxm, loss_smooth_vxm, loss_total_vxm))
    
    return loss_sim_vxm, loss_smooth_vxm, loss_total_vxm
